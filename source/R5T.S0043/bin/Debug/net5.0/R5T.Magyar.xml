<?xml version="1.0"?>
<doc>
    <assembly>
        <name>R5T.Magyar</name>
    </assembly>
    <members>
        <member name="T:R5T.Magyar.ImmutableFluencyAttribute">
            <summary>
            Indicates that the instance returned by a function is a different instance than provided to the function. The function re-instantiated the instance.
            By convention, reference types are mutated by fluent operations (meaning the output instance is the same as the input instance), while value types are re-instantiated by fluent operations (meaning the output instance is a different instance from the input instance).
            This attribute should be applied to functions that break these conventions, but can also be applied to functions following these conventions to provide the comfort of certainty in communication.
            </summary>
        </member>
        <member name="T:R5T.Magyar.MutableFluencyAttribute">
            <summary>
            Indicates that the instance returned by a function is the same instance provided to the function, just mutated.
            By convention, reference types are mutated by fluent operations (meaning the output instance is the same as the input instance), while value types are re-instantiated by fluent operations (meaning the output instance is a different instance from the input instance).
            This attribute should be applied to functions that break these conventions, but can also be applied to functions following these conventions to provide the comfort of certainty in communication.
            </summary>
        </member>
        <member name="T:R5T.Magyar.AsyncResult">
            <summary>
            Asynchronous methods cannot have out or ref parameters.
            In order to return multiple objects, you have to return a single object containg multiple objects.
            Tuples can also be used.
            </summary>
        </member>
        <member name="T:R5T.Magyar.TypedList`1">
            <summary>
            Allows a <see cref="T:System.Collections.Generic.List`1"/> to be handled as distinct named type.
            </summary>
        </member>
        <member name="M:R5T.Magyar.TypedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds input values to the internal list.
            </summary>
        </member>
        <member name="T:R5T.Magyar.EmptyDisposable">
            <summary>
            An empty disposable whose <see cref="M:R5T.Magyar.EmptyDisposable.Dispose"/> method does nothing.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EmptyDisposable.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:R5T.Magyar.HasOutput.From``1(``0)">
            <summary>
            Default assumes a reference type.
            </summary>
        </member>
        <member name="T:R5T.Magyar.HasOutput`1">
            <summary>
            Solves a problem that asynchronous (async) methods cannot use out parameters.
            Instead, an instance providing both whether the output exists, and the result instance if it does, it output from the asynchronous method.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <remarks>
            This is the same idea as suggested in Stack Overflow: https://stackoverflow.com/questions/18716928/how-to-write-a-async-method-with-out-parameter
            An older version of <see cref="T:R5T.Magyar.WasFound`1"/>
            </remarks>
            <seealso cref="T:R5T.Magyar.WasFound`1"/>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.Fragment">
            <summary>
            Example: The hash mark in "google.com/results#First".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.Path">
            <summary>
            Example: The slash in "...google.com/results".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.Port">
            <summary>
            Example: The colon in "localhost:5001".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.Query">
            <summary>
            Example: The question mark in "google.com?q=stuff".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.QueryParameter">
            <summary>
            Example: The ampersand in "google.com/q=stuff&amp;results=true".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.Root">
            <summary>
            Example: The double-slash in "http://google.com".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.Scheme">
            <summary>
            Example: The colon in "https://...".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.UserDetails">
            <summary>
            Example: The colon in "http://user:pass@www.mysite.com".
            </summary>
        </member>
        <member name="P:R5T.Magyar.UrlTokenSeparators.UserInfo">
            <summary>
            Example: The at symbol in "http://user:pass@www.mysite.com".
            </summary>
        </member>
        <member name="T:R5T.Magyar.WasFound`1">
            <summary>
            Solves a problem that asynchronous (async) methods cannot use out parameters.
            Instead, an instance providing both whether the output exists, and the result instance if it does, it output from the asynchronous method.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <remarks>
            A newer version of <see cref="T:R5T.Magyar.HasOutput`1"/>
            This is the same idea as suggested in Stack Overflow: https://stackoverflow.com/questions/18716928/how-to-write-a-async-method-with-out-parameter
            </remarks>
            <seealso cref="T:R5T.Magyar.HasOutput`1"/>
        </member>
        <member name="M:R5T.Magyar.WasFound.From``1(``0)">
            <summary>
            Default assumes a reference type.
            </summary>
        </member>
        <member name="M:R5T.Magyar.WasFound.FromArray``1(``0[])">
            <summary>
            Was found only if the array is non-null and non-empty.
            </summary>
        </member>
        <member name="T:R5T.Magyar.WasSuccessful`1">
            <summary>
            Solves a problem that asynchronous (async) methods cannot use out parameters.
            Instead, an instance providing both whether the output exists, and the result instance if it does, it output from the asynchronous method.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <remarks>
            A newer version of <see cref="T:R5T.Magyar.HasOutput`1"/>
            This is the same idea as suggested in Stack Overflow: https://stackoverflow.com/questions/18716928/how-to-write-a-async-method-with-out-parameter
            </remarks>
            <seealso cref="T:R5T.Magyar.HasOutput`1"/>
        </member>
        <member name="M:R5T.Magyar.WasSuccessful.From``1(``0)">
            <summary>
            Default assumes a reference type.
            </summary>
        </member>
        <member name="T:R5T.Magyar.Documentation">
            <summary>
            Extensions and helpers .NET Standard types.
            </summary>
        </member>
        <member name="M:R5T.Magyar.DuplicateValueHandlingExtensions.TryChoose``1(R5T.Magyar.DuplicateValueHandling,``0,``0,``0@)">
            <summary>
            Note: assumes that <paramref name="existing"/> and <paramref name="duplicate"/> have already been determined to be duplicates.
            This method just follows the "try-" pattern and informs as to whether choosing a duplicate would succeed, or if an exception would be thrown based on the <see cref="T:R5T.Magyar.DuplicateValueHandling"/> value.
            In case of false, the output <paramref name="chosen"/> value is the default value of <typeparamref name="TValue"/>.
            In case of true, the chosen value is either the existing (<see cref="F:R5T.Magyar.DuplicateValueHandling.KeepFirst"/>) or duplicate (<see cref="F:R5T.Magyar.DuplicateValueHandling.UseLast"/>) value depending on the value of <paramref name="duplicateValueHandling"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.DuplicateValueHandlingExtensions.ChooseWouldFail``1(R5T.Magyar.DuplicateValueHandling,``0,``0,``0@)">
            <summary>
            Note: assumes that <paramref name="existing"/> and <paramref name="duplicate"/> have already been determined to be duplicates.
            This method is meant for use in an if()-block, and informs as to whether choosing a duplicate would succeed, or if an exception would be thrown based on the <see cref="T:R5T.Magyar.DuplicateValueHandling"/> value.
            In case of false, the output <paramref name="chosen"/> value is the default value of <typeparamref name="TValue"/>.
            In case of true, the chosen value is either the existing (<see cref="F:R5T.Magyar.DuplicateValueHandling.KeepFirst"/>) or duplicate (<see cref="F:R5T.Magyar.DuplicateValueHandling.UseLast"/>) value depending on the value of <paramref name="duplicateValueHandling"/>.
            </summary>
        </member>
        <member name="T:R5T.Magyar.UnrecognizedEnumerationValueException">
            <summary>
            An exception for when where the string representation of a enumeration value is unrecognizable as one of the values of the enumeration.
            Useful in the default case of a switch statement for parsing a string to an enumeration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.GuidExtensions.ToStringStandard(System.Guid)">
            <summary>
            The standard string representation of a GUID.
            Uses <see cref="M:R5T.Magyar.Extensions.GuidExtensions.ToStringUppercase(System.Guid)"/>.
            </summary>
            <remarks>
            See the discussion of formats here: https://docs.microsoft.com/en-us/dotnet/api/system.guid.tostring?view=netcore-2.2.
            </remarks>
        </member>
        <member name="M:R5T.Magyar.Extensions.GuidExtensions.ToStringUppercase(System.Guid)">
            <summary>
            Returns a GUID in uppercase format.
            Example: 382C74C3-721D-4F34-80E5-57657B6CBC27.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.GuidExtensions.ToStringUppercaseBracketed(System.Guid)">
            <summary>
            Returns a GUID in uppercase format, bracketed.
            Example: {382C74C3-721D-4F34-80E5-57657B6CBC27}.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.ICollectionExtensions.RemoveRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Different than <see cref="M:System.Collections.Generic.ICollection`1.Clear"/>, this allows use of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to specific items to remove.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.ObjectExtensions.As``2(``1)">
            <summary>
            Useful for resolving ambiguous extension methods.
            For example an instance is an IX, which implements IA and IB, both of which have extension method M().
            If the instance was typed as IA or IB, there would be no ambiguity about which extension method to call. However, because IX is both an IA and IB, there is no preference for which extension method to call since all interfaces are equals.
            Thus you can cast the type to the desired interface type to select the desired extension method.
            </summary>
            <seealso cref="M:R5T.Magyar.Extensions.ObjectExtensions.Cast``2(``0)"/>
        </member>
        <member name="M:R5T.Magyar.Extensions.ObjectExtensions.Cast``2(``0)">
            <summary>
            <inheritdoc cref="M:R5T.Magyar.Extensions.ObjectExtensions.As``2(``1)" path="/summary"/>
            </summary>
            <seealso cref="M:R5T.Magyar.Extensions.ObjectExtensions.As``2(``1)"/>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringArrayExtensions.Join(System.String[],System.String)">
            <summary>
            Note, this functionality already exists in BCL as <see cref="M:System.String.Join(System.String,System.Object[])"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.ExceptFirst(System.String,System.Int32)">
            <summary>
            Returns the input string, except without the first specified number of characters (a positive integer).
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.ExceptFirst(System.String)">
            <summary>
            Returns the input string, except without the first character.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.ExceptLast(System.String,System.Int32)">
            <summary>
            Returns the input string, except without the last specified number of characters (a positive integer).
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.ExceptLast(System.String)">
            <summary>
            Returns the input string, except without the last character.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.ExceptLast(System.String,System.String)">
            <summary>
            Removes a number of characters equal to the length of the suffix from the input <paramref name="string"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.Last(System.String,System.Int32)">
            <summary>
            Gets the last number of characters in a string.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.LastString(System.String)">
            <summary>
            Gets the last character in a string as a string.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Extensions.StringExtensions.Split(System.String,System.String,System.StringSplitOptions)">
            <summary>
            An ease-of-use overload that allows using a single string as the separator (instead of a full string array).
            Fixes the lack of a string.Split(params string[]) function.
            </summary>
        </member>
        <member name="M:R5T.Magyar.ApprovalStatusExtensions.EnsureIsNotPending(R5T.Magyar.ApprovalStatus)">
            <summary>
            Ensures an <see cref="T:R5T.Magyar.ApprovalStatus"/> is not <see cref="F:R5T.Magyar.ApprovalStatus.Pending"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.ApprovalStatusExtensions.EnsureIsDecided(R5T.Magyar.ApprovalStatus)">
            <summary>
            Ensures an <see cref="T:R5T.Magyar.ApprovalStatus"/> has been decided (and is not still <see cref="F:R5T.Magyar.ApprovalStatus.Pending"/>).
            </summary>
            <remarks>
            Uses <see cref="M:R5T.Magyar.ApprovalStatusExtensions.EnsureIsNotPending(R5T.Magyar.ApprovalStatus)"/>.
            </remarks>
        </member>
        <member name="M:R5T.Magyar.OrganizationCourtStatusExtensions.EnsureIsNotPending(R5T.Magyar.OrganizationCourtStatus)">
            <summary>
            Ensures an <see cref="T:R5T.Magyar.OrganizationCourtStatus"/> is not <see cref="F:R5T.Magyar.OrganizationCourtStatus.Pending"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.OrganizationCourtStatusExtensions.EnsureIsDecided(R5T.Magyar.OrganizationCourtStatus)">
            <summary>
            Ensures an <see cref="T:R5T.Magyar.OrganizationCourtStatus"/> has been decided (and is not still <see cref="F:R5T.Magyar.OrganizationCourtStatus.Pending"/>).
            </summary>
            <remarks>
            Uses <see cref="M:R5T.Magyar.OrganizationCourtStatusExtensions.EnsureIsNotPending(R5T.Magyar.OrganizationCourtStatus)"/>.
            </remarks>
        </member>
        <member name="M:R5T.Magyar.StringExtensions.ExceptEnding(System.String,System.String)">
            <summary>
            Returns the string, without the ending.
            </summary>
        </member>
        <member name="M:R5T.Magyar.UriBuilderExtensions.SetServer(System.UriBuilder,System.String)">
            <summary>
            Server can include both host and port.
            </summary>
        </member>
        <member name="M:R5T.Magyar.WasFoundExtensions.AsBoolean``1(R5T.Magyar.WasFound{``0})">
            <summary>
            Useful in the cases where C# does not realize it should use the implicit conversion operator (such as returning when you need to return a boolean and C# will not accept a WasFound).
            </summary>
        </member>
        <member name="M:R5T.Magyar.WasFoundExtensions.ConvertDefault``2(R5T.Magyar.WasFound{``0})">
            <summary>
            With no converter specified, the default of <typeparamref name="TDestination"/> is returned.
            </summary>
        </member>
        <member name="M:R5T.Magyar.ActionHelper.DoNothing">
            <summary>
            Does nothing.
            This is the "empty" action.
            </summary>
        </member>
        <member name="M:R5T.Magyar.ActionHelper.DoNothing``1(``0)">
            <summary>
            Does nothing with input.
            This is the "empty" action.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnrecognizedEnumerationValueMessage(System.String,System.String)">
            <summary>
            Gets a message indicating that the input string representation of an enumeration value was not recognized among the string representations of a possible values of the enumeration type.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnrecognizedEnumerationValueMessage``1(System.String)">
            <summary>
            Gets a message indicating that the input string representation of an enumeration value was not recognized among the string representations of a possible values of the <typeparamref name="TEnum"/> enumeration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnrecognizedEnumerationValueException(System.String,System.String)">
            <summary>
            Produces an exception in the case where the string representation of a enumeration value is unrecognizable as one of the values of the <paramref name="enumerationTypeFullName"/> enumeration.
            Useful in the default case of a switch statement for parsing a string to an enumeration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnrecognizedEnumerationValueException(System.Type,System.String)">
            <summary>
            Produces an exception in the case where the string representation of a enumeration value is unrecognizable as one of the values of the <paramref name="enumerationType"/> enumeration.
            Useful in the default case of a switch statement for parsing a string to an enumeration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnrecognizedEnumerationValueException``1(System.String)">
            <summary>
            Produces an exception in the case where the string representation of a enumeration value is unrecognizable as one of the values of the <typeparamref name="TEnum"/> enumeration.
            Useful in the default case of a switch statement for parsing a string to an enumeration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.RepresentationUnrecognizedException``1(System.String)">
            <summary>
            Produces an exception in the case where the string representation of a enumeration value is unrecognizable as one of the values of the <typeparamref name="TEnum"/> enumeration.
            Useful in the default case of a switch statement for parsing a string to an enumeration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnrecognizedEnumerationValueMessageLegacy``1(System.String)">
            <summary>
            Gets a message indicating that the input string representation of an enumeration value was not recognized among the string representations of a possible values of the <typeparamref name="TEnum"/> enumeration.
            Note: This legacy method that restricts <typeparamref name="TEnum"/> as a struct, instead of an <see cref="T:System.Enum"/>, is provided since <see cref="M:System.Enum.TryParse``1(System.String,``0@)"/> restricts on struct instead of <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.Parse``1(System.String)">
            <summary>
            Parses the string representation of an enumeration value to an value of the <typeparamref name="TEnum"/> enumeration.
            Note: this method restricts <typeparamref name="TEnum"/> as a struct, instead of an <see cref="T:System.Enum"/>, since <see cref="M:System.Enum.TryParse``1(System.String,``0@)"/> restricts on struct instead of <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnexpectedEnumerationValueMessage``1(``0)">
            <summary>
            Gets a message indicating the the input value of the <typeparamref name="TEnum"/> enumeration was unexpected.
            This is useful in producing an error in the default case for switch statements based on enumeration values.
            </summary>
            <remarks>
            See: https://stackoverflow.com/questions/13645149/what-is-the-correct-exception-to-throw-for-unhandled-enum-values
            </remarks>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.UnexpectedEnumerationValueException``1(``0)">
            <summary>
            Produces an exception for the situation where a value of the <typeparamref name="TEnum"/> enumeration was unexpected.
            This is useful in producing an error in the default case for switch statements based on enumeration values.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.SwitchDefaultCaseException``1(``0)">
            <summary>
            Produces an exception for use in the default case of a switch statement based on values of the <typeparamref name="TEnum"/> enumeration.
            Note: there is no method just throwing the exception, as the VS linter does not detect that a method call will always produce an exception, and thus demands that switch default case behavior cannot fall through one default case to another. The throw keyword in the switch default case must be present.
            </summary>
        </member>
        <member name="M:R5T.Magyar.EnumerationHelper.GetValues``1">
            <summary>
            Gets all values of the <typeparamref name="TEnum"/> enumeration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.ExecutableFilePathHelper.GetCommandLineArgumentValue">
            <summary>
            Get the current executable's path location from the first argument of the command-line incantation used to start the current process.
            </summary>
        </member>
        <member name="M:R5T.Magyar.ExecutableFilePathHelper.GetEntryAssemblyValue">
            <summary>
            Gets the current executable's path location from the entry assembly's location.
            </summary>
        </member>
        <member name="M:R5T.Magyar.ExecutableFilePathHelper.GetExecutableFilePath">
            <summary>
            Gets the path location of the executable via the default method, <see cref="M:R5T.Magyar.ExecutableFilePathHelper.GetCommandLineArgumentValue"/>.
            </summary>
            <remarks>
            There are multiple ways to get the location of the executable, and depending on context (unit test, debugging in Visual Studio, or production) different locations are returned.
            The command line argument is chosen as the default since this is the way the program is actually run by the operating system.
            </remarks>
        </member>
        <member name="M:R5T.Magyar.GuidHelper.GetNewGuidString">
            <summary>
            Uses the <see cref="M:R5T.Magyar.Extensions.GuidExtensions.ToStringStandard(System.Guid)"/> functionality.
            </summary>
        </member>
        <member name="P:R5T.Magyar.PathHelper.CurrentDirectoryPathValue">
            <summary>
            Gets the current directory path.
            Uses <see cref="P:System.Environment.CurrentDirectory"/>.
            </summary>
        </member>
        <member name="P:R5T.Magyar.PathHelper.UserProfileDirectoryPathValue">
            <summary>
            Gets the current user's profile directory path.
            Uses <see cref="F:System.Environment.SpecialFolder.UserProfile"/>.
            </summary>
        </member>
        <member name="P:R5T.Magyar.PathHelper.ExecutablePathCommandLineArgumentValue">
            <summary>
            Get the current executable's path location from the first argument of the command-line incantation used to start the current process.
            </summary>
        </member>
        <member name="P:R5T.Magyar.PathHelper.ExecutablePathEntryAssemblyValue">
            <summary>
            Gets the current executable's path location from the entry assembly's location.
            </summary>
        </member>
        <member name="P:R5T.Magyar.PathHelper.ExecutablePathValue">
            <summary>
            Gets the path location of the executable via the default method, <see cref="P:R5T.Magyar.PathHelper.ExecutablePathCommandLineArgumentValue"/>.
            </summary>
            <remarks>
            There are multiple ways to get the location of the executable, and depending on context (unit test, debugging in Visual Studio, or production) different locations are returned.
            The command line argument is chosen as the default since this is the way the program is actually run by the operating system.
            </remarks>
        </member>
        <member name="M:R5T.Magyar.PathHelper.GetRandomFileNameWithoutExtension">
            <summary>
            Gets a random file name without extension.
            </summary>
        </member>
        <member name="M:R5T.Magyar.UriHelper.New">
            <summary>
            Uses the <see cref="M:R5T.Magyar.UriHelper.NewBetterDefaults"/> method.
            </summary>
        </member>
        <member name="M:R5T.Magyar.UriHelper.NewBetterDefaults">
            <summary>
            Uses the <see cref="M:R5T.Magyar.UriHelper.NewBetterDefaults"/> methods to set better default values than <see cref="T:System.UriBuilder"/> parameterless constructor.
            </summary>
        </member>
        <member name="T:R5T.Magyar.IGUIDed">
            <summary>
            Has a GUID (Globally Unique ID).
            </summary>
        </member>
        <member name="T:R5T.Magyar.IIDed">
            <summary>
            Has an ID.
            </summary>
        </member>
        <member name="T:R5T.Magyar.IO.TabinatedWriter">
            <summary>
            A <see cref="T:System.IO.TextWriter"/> wrapper that allows prefixing lines with consistent tabination.
            </summary>
            <remarks>
            Based on: https://github.com/MinexAutomation/R5T.NetStandard.IO.Serialization/blob/master/source/R5T.NetStandard.IO.Serialization/Code/Classes/TabinatedWriter.cs
            </remarks>
        </member>
        <member name="T:R5T.Magyar.Results.ActionResult">
            <summary>
            Represents the result of an action (an operation where there is no output value).
            </summary>
        </member>
        <member name="T:R5T.Magyar.Results.FunctionResult`1">
            <summary>
            Represents the result of a function (an operation where there is an output value).
            </summary>
            <typeparam name="T">The type of the output of the function which has this result.</typeparam>
        </member>
        <member name="T:R5T.Magyar.Xml.CustomXmlWriterBase">
            <summary>
            Note: class is almost useless because XmlWriter is almost useless!
            The problem is that there is no expansion point for after the closing '>' (alligator) of an element (opening element) is written. Thus there is no way to customize line spacing.
            This class is preserved since work was required to create it.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XElementExtensions.AcquireElement(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Get the element with the speicified name, if it exists, or adds an element with the specified if it does not exist.
            Adds the element as well.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XElementExtensions.GetChild(System.Xml.Linq.XElement,System.String)">
            <summary>
            Default uses <see cref="M:R5T.Magyar.Xml.XElementExtensions.GetChildSingle(System.Xml.Linq.XElement,System.String)"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XElementExtensions.GetChildValue(System.Xml.Linq.XElement,System.String)">
            <summary>
            Uses <see cref="M:R5T.Magyar.Xml.XElementExtensions.GetChildValueSingle(System.Xml.Linq.XElement,System.String)"/> as the default.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XElementExtensions.GetElement(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if the <see cref="T:System.Xml.Linq.XElement"/> does not have an element of the specified name.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XElementExtensions.HasChild(System.Xml.Linq.XElement,System.String,System.Xml.Linq.XElement@)">
            <summary>
            Uses <see cref="M:R5T.Magyar.Xml.XElementExtensions.HasChildFirstOrDefault(System.Xml.Linq.XElement,System.String,System.Xml.Linq.XElement@)"/> as the default.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XElementExtensions.Normalize(System.Xml.Linq.XElement)">
            <summary>
            Normalizes an <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <remarks>
            Source: https://weblogs.asp.net/marianor/easy-way-to-compare-two-xmls-for-equality
            </remarks>
        </member>
        <member name="M:R5T.Magyar.Xml.XElementExtensions.RemoveAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Default implementation uses <see cref="M:R5T.Magyar.Xml.XElementExtensions.RemoveAttributeOnlyIfExists(System.Xml.Linq.XElement,System.Xml.Linq.XName)"/>.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterHelper.NewOmitDeclaration_Synchronous(System.IO.Stream)">
            <summary>
            The System XML writer includes an XML declaration by default, however this is often not desired.
            An XML writer can be created with settings specifying to omit the XML declaration, but other settings must be set to get the desired default behavior.
            This method produces an XML writer that omits the declaration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterHelper.NewOmitDeclaration(System.IO.Stream)">
            <inheritdoc cref="M:R5T.Magyar.Xml.XmlWriterHelper.NewOmitDeclaration_Synchronous(System.IO.Stream)"/>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterHelper.New_Synchronous(System.IO.Stream)">
            <summary>
            Gets the standard XML writer.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterHelper.New(System.IO.Stream)">
            <inheritdoc cref="M:R5T.Magyar.Xml.XmlWriterHelper.New_Synchronous(System.IO.Stream)"/>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterSettingsHelper.GetIndent">
            <summary>
            Gets a simple indenting XML writer settings instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterSettingsHelper.GetNoDeclaration_Synchronous">
            <summary>
            The System XML writer includes an XML declaration by default, however this is often not desired.
            An XML writer can be created with settings specifying to omit the XML declaration, but other settings must be set to get the desired default behavior.
            This method produces XML writer settings that replicate the default settings, except specifying to omit the declaration.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterSettingsHelper.GetNoDeclaration">
            <inheritdoc cref="M:R5T.Magyar.Xml.XmlWriterSettingsHelper.GetNoDeclaration_Synchronous"/>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterSettingsHelper.GetStandardSettings_Synchronous">
            <summary>
            Gets the standard XML writer settings.
            </summary>
        </member>
        <member name="M:R5T.Magyar.Xml.XmlWriterSettingsHelper.GetStandardSettings">
            <summary>
            Gets the standard XML writer settings.
            </summary>
        </member>
        <member name="T:System.Additions.EqualityComparison`1">
            <summary>
            An equality comparison.
            </summary>
        </member>
        <member name="T:System.Additions.IEqualityComparer`1">
            <summary>
            Tests two instances for equality.
            Separate from <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>, this type does not require defining <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/>.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.IDistinctEnumerable`1">
            <summary>
            Indicates (but does not guarantee) that an enumerable contains distinct elements.
            /// Extension methods can be used to verify/ensure the enumerable contains unique if desirable (and the cost of computation is justified).
            </summary>
            <remarks>
            Conceptually similar to <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>, but indicates the distict property instead of being read-only.
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.IDistinctList`1">
            <summary>
            Similar to <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>, there should be a type that communicates its elements are distinct.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.IDistinctValuedDictionary`2">
            <summary>
            The <see cref="T:System.Collections.Generic.Dictionary`2"/> type must have distinct keys, but it can have non-distinct values.
            With an <see cref="T:System.Collections.Generic.IDistinctValuedDictionary`2"/>, both the keys and values are distinct.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.ISortedAscendingEnumerable`1">
            <summary>
            Indicates (but does not guarantee) that an enumerable is sorted in ascending order.
            Extension methods can be used to verify/ensure the enumerable is sorted in ascending order if desirable (and the cost of computation is justified).
            </summary>
            <remarks>
            There is a <see cref="T:System.Collections.Generic.SortedList`2"/> class, but it includes an extraneous extra key type parameter.
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.ISortedDescendingEnumerable`1">
            <summary>
            Indicates (but does not guarantee) that an enumerable is sorted in descending order.
            Extension methods can be used to verify/ensure the enumerable is sorted in descending order if desirable (and the cost of computation is justified).
            </summary>
            <remarks>
            There is a <see cref="T:System.Collections.Generic.SortedList`2"/> class, but it includes an extraneous extra key type parameter.
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.ISortedEnumerable`1">
            <summary>
            Indicates (but does not guarantee) that an enumerable is sorted (in an implicit order).
            Extension methods can be used to verify/ensure the enumerable is sorted (in an implicit) order if desirable (and the cost of computation is justified).
            </summary>
            <remarks>
            There is the <see cref="T:System.Collections.Generic.SortedList`2"/> class, but it includes an extraneous extra key type parameter.
            There is also the <see cref="T:System.Linq.IOrderedEnumerable`1"/> interface, but it demands an implication of a verification method instead of leaving that to an optional extension method.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Invert``2(System.Collections.Generic.IDictionary{``0,``1},R5T.Magyar.DuplicateValueHandling)">
            <summary>
            Because the input <see cref="T:System.Collections.Generic.IDictionary`2"/> is not an <see cref="T:System.Collections.Generic.IDistinctValuedDictionary`2"/>, duplicate value handling must be specified.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.GetRepeatedElements``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Get all repeated elements (including all elements in each series of repeats).
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.GetDistinctRepeatedElements``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Get one of each repeated element.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.VerifyDistinctEnumerable``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Named with -Enumerable to allow resolution of ambiguous IList.VerifyDistinct() vs. IEnumerable.VerifyDistinct() when required.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.VerifyDistinctEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Named with -Enumerable to allow resolution of ambiguous IList.VerifyDistinct() vs. IEnumerable.VerifyDistinct() when required.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.ToSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Chooses ascending is the default sort order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.ToSorted``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Chooses ascending as the default sort order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.IsSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Chooses sorted ascending as the default sort order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.IsSorted``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Chooses sorted ascending as the default sort order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.VerifySorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Chooses sorted ascending as the default sort order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.VerifySorted``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Chooses sorted ascending as the default sort order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.EnsureSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Chooses sorted ascending as the default sort order.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.EnsureSorted``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Chooses sorted ascending as the default sort order.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetDistinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Chooses <see cref="M:System.Linq.IEnumerableExtensions.GetDistinct_KeepFirst``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/> as the default.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetDistinct``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Chooses <see cref="M:System.Linq.IEnumerableExtensions.GetDistinct_KeepFirst``1(System.Collections.Generic.IEnumerable{``0})"/> as the default.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EmptyIfDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an empty enumerable if the input enumerable has the default IEnumerable&lt;T&gt; value.
            The default for an IEnumerable&lt;T&gt; is null. This can cause problems with null reference exceptions.
            This method allows easily providing an empty enumerable if the input is default (with the drawback that you have to remember to use it).
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Evaluate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Selects array as the preferred data structure for an evaluated enumerable.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ExceptWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Same as where, except that the output contains values where the predicate is false.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForEach_WithCounter``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Counter starts at one by default (unlike index, which starts at zero by default).
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetTrailingAppendix``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Linq.IListExtensions.GetTrailingAppendix``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetTrailingComplement``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the elements in <paramref name="elements"/> that are after the last common element in other elements.
            Example: elements [A, B, C, E] with other elements [A, B, D, E] would return [C, E]. This is not just a set complement.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.LastIndexWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the last index where the predicate is true, else if the predicate is not true for any of the items of the enumerable, returns <see cref="P:System.IndexHelper.NotFound"/>.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Multiple``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Quality-of-life overload for <see cref="M:System.Linq.IEnumerableExtensions.HasMoreThanOne``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.None_OLD``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns true if there are no entries.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Now_OLD``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Selects array as the preferred data structure for an evaluated enumerable.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.IndexWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first index where the predicate is true, else if the predicate is not true for any of the items of the enumerable, returns <see cref="P:System.IndexHelper.NotFound"/>.
            </summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.NthToLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Get the Nth-to-last element.
            N starts at 1st-to-last is the last.
            Problematic evaluation of the enumerable (ToArray).
            </summary>
        </member>
        <member name="M:System.Linq.IListExtensions.GetTrailingAppendix``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Returns the elements of <paramref name="elements"/> that occur after the common initial elements specified by <paramref name="otherElements"/>.
            If <paramref name="elements"/> does not start with the elements of <paramref name="otherElements"/>, an exception is thrown.
            </summary>
        </member>
        <member name="M:System.Linq.IListExtensions.VerifyDistinctList``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Named with -List to allow resolution of ambiguous IList.VerifyDistinct() vs. IEnumerable.VerifyDistinct() when required.
            </summary>
        </member>
        <member name="M:System.HashSetExtensions.AddRange``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Chooses <see cref="M:System.HashSetExtensions.AddRangeKeepLast``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})"/> as the default behavior (which it is for <see cref="T:System.Collections.Generic.HashSet`1"/>).
            </summary>
        </member>
        <member name="M:System.HashSetExtensions.AddRangeKeepLast``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            If the hash set already contains the item, replace it with any later items.
            This is the default behavior for <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
        </member>
        <member name="M:System.HashSetExtensions.AddRangeKeepFirst``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            If the hash set already contains the item, do not replace it with any later items.
            </summary>
        </member>
        <member name="M:System.IDictionaryExtensions.AddValueByKey``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}},``0,``1)">
            <summary>
            Adds a value to the list of values corresponding to the provided key.
            If the key does not exist, a new list of valies is created for it, and the value is then added to the new list.
            </summary>
        </member>
        <member name="M:System.IListExtensions.GetIndexForInsertionAtEnd``1(System.Collections.Generic.IList{``0})">
            <summary>
            Gets one past the last index of the list to allow an element to be "inserted" at the end of the list.
            </summary>
        </member>
        <member name="M:System.IListExtensions.GetIndexForInsertionAtEnd``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <inheritdoc cref="M:System.IListExtensions.GetIndexForInsertionAtEnd``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:System.StringExtensions.BeginningByIndex(System.String,System.Int32)">
            <summary>
            Returns the beginning, not including the character at the index (index of 1, i.e. the second character, would return the first character only).
            </summary>
        </member>
        <member name="M:System.StringExtensions.Beginning(System.String,System.Int32)">
            <inheritdoc cref="M:System.StringExtensions.BeginningByIndex(System.String,System.Int32)"/>
        </member>
        <member name="M:System.StringExtensions.ExceptFirstCharacter(System.String)">
            <summary>
            Provides the input string, but without its first character.
            </summary>
        </member>
        <member name="M:System.StringExtensions.IndexOfEnd(System.String)">
            <summary>
            The index of the end is one past the index of the last character.
            This is the same as the length of the string.
            </summary>
        </member>
        <member name="T:System.TypedListExtensions">
            <summary>
            Placed in <see cref="N:System"/> namespace so as to be available anywhere you might have an instance of a <see cref="T:R5T.Magyar.TypedList`1"/>.
            </summary>
        </member>
        <member name="P:System.ComparisonHelper.LessThan">
            <summary>
            Indicates that x is less than y.
            </summary>
        </member>
        <member name="P:System.ComparisonHelper.GreaterThan">
            <summary>
            Indicates that x is greater than y.
            </summary>
        </member>
        <member name="M:System.EnumerableHelper.ProcessSingular``2(System.Func{System.Collections.Generic.IDistinctEnumerable{``0},System.Threading.Tasks.Task{System.Collections.Generic.IDistinctValuedDictionary{``0,``1}}},``0)">
            <summary>
            Random overload for <see cref="T:System.Collections.Generic.IDistinctValuedDictionary`2"/> since C# compiler does not see covariance to <see cref="T:System.Collections.Generic.IDictionary`2"/> and specifying the dictionary type parameter for <see cref="T:System.Collections.Generic.IDistinctValuedDictionary`2"/> is obnoxious.
            </summary>
        </member>
        <member name="M:System.FunctionHelper.Run``1(System.Func{``0,System.Boolean},``0,System.Boolean)">
            <summary>
            If the input <paramref name="value"/> is not an object, the <paramref name="defaultStool"/> value is returned.
            </summary>
        </member>
        <member name="M:System.IndexHelper.IsFirstIndex(System.Int32)">
            <summary>
            Assumes a zero-based first index.
            </summary>
        </member>
        <member name="M:System.IndexHelper.IsNotFirstIndex(System.Int32)">
            <inheritdoc cref="M:System.IndexHelper.IsFirstIndex(System.Int32)"/>
        </member>
        <member name="M:System.IndexHelper.LastIndex(System.Int32)">
            <summary>
            The last index is simply the count of elements minus one.
            NOTE: For zero counts, this will return -1.
            </summary>
        </member>
        <member name="M:System.IndexHelper.LastInsertionIndex(System.Int32)">
            <summary>
            The last index at which you could insert is simply the count of elements (one more than the index of the last element).
            </summary>
        </member>
        <member name="M:System.IndexHelper.ToLength_Inclusive(System.Int32)">
            <summary>
            Gets the length of the list that would include the index. (Adds 1 (one) to the index.)
            </summary>
        </member>
        <member name="M:System.IndexHelper.ToLength_Exclusive(System.Int32)">
            <summary>
            Gets the length of the list that would exclude the index. (Returns the index.)
            </summary>
        </member>
        <member name="F:System.StringHelper.IndexOfNotFound">
            <summary>
            The return value of the <see cref="M:System.String.IndexOf(System.String)"/> method when the search string is not found.
            </summary>
        </member>
        <member name="M:System.StringHelper.IsFound(System.Int32)">
            <summary>
            Useful for testing the return value of the <see cref="M:System.String.IndexOf(System.String)"/> method to see if the search string was found.
            </summary>
        </member>
        <member name="M:System.StringHelper.IsGreaterThan(System.String,System.String)">
            <summary>
            <paramref name="rhs"/> is less than <paramref name="lhs"/>.
            </summary>
        </member>
        <member name="M:System.StringHelper.IsLessThan(System.String,System.String)">
            <summary>
            <paramref name="lhs"/> is less than <paramref name="rhs"/>.
            </summary>
        </member>
        <member name="M:System.StringHelper.EncodeBase64(System.String)">
            <summary>
            
            </summary>
            <remarks>
            Source: https://jasonwatmore.com/post/2020/09/12/c-encode-and-decode-base64-strings
            </remarks>
        </member>
        <member name="M:System.StringHelper.EncodeBase64Url(System.String,R5T.Magyar.PaddingPolicy)">
            <summary>
            
            </summary>
            <remarks>
            Source: https://github.com/neosmart/UrlBase64/blob/master/UrlBase64/UrlBase64.cs
            </remarks>
        </member>
        <member name="M:System.StringHelper.IsEmpty(System.String)">
            <summary>
            Determines if the input is specifically the <see cref="P:R5T.Magyar.Strings.Empty"/> string.
            </summary>
        </member>
        <member name="M:System.StringHelper.IsNotEmpty(System.String)">
            <summary>
            Determines if the input is specifically *not* the <see cref="P:R5T.Magyar.Strings.Empty"/> string.
            </summary>
        </member>
        <member name="M:System.StringHelper.IsNull(System.String)">
            <summary>
            Determines if the input is specifically the <see cref="P:R5T.Magyar.Strings.Null"/> string.
            </summary>
        </member>
        <member name="M:System.StringHelper.IsNotNull(System.String)">
            <summary>
            Determines if the input is specifically *not* the <see cref="P:R5T.Magyar.Strings.Null"/> string.
            </summary>
        </member>
        <member name="M:System.IO.DirectoryHelper.CreateDirectoryOkIfExists(System.String)">
            <summary>
            Creates a directory idempotently (meaning there is no problem with issuing the command multiple times). 
            Note: <see cref="M:System.IO.Directory.CreateDirectory(System.String)"/> already does not throw an exception if you create a directory that already exists. However, it's hard to remember this fact. Thus, this method name makes that fact explicit.
            </summary>
        </member>
        <member name="M:System.IO.DirectoryHelper.EnsureDirectoryExists(System.String)">
            <summary>
            Ensures that a directory exists.
            Just an quality-of-life rename for the idempotent <see cref="M:System.IO.DirectoryHelper.CreateDirectoryOkIfExists(System.String)"/>.
            </summary>
        </member>
        <member name="M:System.IO.DirectoryHelper.DeleteRobust(System.String)">
            <summary>
            Deletes a directory path.
            The <see cref="M:System.IO.Directory.Delete(System.String)"/> method throws a <see cref="T:System.IO.DirectoryNotFoundException"/> if attempting to delete a non-existent directory. This is annoying.
            All you really want is the directory to not exist, so this method simply takes care of checking if the directory exists.
            Also annoying, you need to specify the recursive option to delete a directory with anything in it. This method also takes care of specifying true for the recursive option.
            Even more annoying, even after specifying the recursive option, the system method will not delete read-only files. Thus this method disables read-only options on all files recursively.
            </summary>
        </member>
        <member name="M:System.IO.DirectoryHelper.DisableReadOnly(System.IO.DirectoryInfo)">
            <summary>
            Remove the read-only attribute from all files.
            </summary>
            <remarks>
            Adapted from: https://stackoverflow.com/questions/1982209/cannot-programatically-delete-svn-working-copy
            </remarks>
        </member>
        <member name="M:System.IO.DirectoryHelper.EnumerateFilePaths(System.String)">
            <summary>
            Note, there is no System.IO asynchronous directory contents enumeration functionality. So must be synchronous.
            </summary>
        </member>
        <member name="M:System.IO.DirectoryHelper.IsDirectory(System.String)">
            <summary>
            Determine if a path is a directory.
            </summary>
            <remarks>
            StackOverflow: https://stackoverflow.com/questions/1395205/better-way-to-check-if-a-path-is-a-file-or-a-directory
            </remarks>
        </member>
        <member name="M:System.IO.FileHelper.ActuallyReadAllLines(System.String)">
            <summary>
            Actually reads all lines. The <see cref="M:System.IO.File.ReadLines(System.String)"/> method omits blank lines, instead adding the new line character to the previous line!
            </summary>
        </member>
        <member name="M:System.IO.FileHelper.DeleteOnlyIfExists(System.String)">
            <summary>
            Deletes a file if it exists.
            Note: the <see cref="M:System.IO.File.Delete(System.String)"/> implementation is idempotent, meaning it will not throw an exception if the file does not exist.
            However, it's easy to forget this fact about the method's behavior. Thus this method provides a convenient name that communicates the expected behavior.
            </summary>
        </member>
        <member name="M:System.IO.FileHelper.Exists(System.String)">
            <summary>
            Note, there is no system supported asynchrons method for testing file existence. :-( See: https://stackoverflow.com/questions/19076652/check-if-a-file-exists-async
            </summary>
        </member>
        <member name="M:System.IO.FileHelper.IsFile(System.String)">
            <summary>
            Determine if a path is a file.
            </summary>
        </member>
        <member name="M:System.IO.FileHelper.ReadAllLinesSynchronous(System.String)">
            <summary>
            Ease of use name for the <see cref="M:System.IO.FileHelper.ActuallyReadAllLines(System.String)"/> method.
            </summary>
        </member>
        <member name="M:System.IO.FileStreamHelper.NewWrite(System.String,System.Boolean)">
            <summary>
            Eases construction of a new <see cref="T:System.IO.FileStream"/> with a best-practice implementation of handling the overwrite parameter.
            </summary>
        </member>
        <member name="M:System.IO.FileStreamHelper.NewRead(System.String)">
            <summary>
            Eases construction of a new <see cref="T:System.IO.FileStream"/> for reading.
            </summary>
        </member>
        <member name="T:System.IO.FileWriterHelper">
            <summary>
            Helper for writing files.
            </summary>
            <remarks>
            Note: there is no FileWriter class in System.IO. So while <see cref="T:System.IO.FileWriterHelper"/> is modeled on <see cref="T:System.IO.StreamWriterHelper"/> and <see cref="T:System.IO.FileStreamHelper"/>, just don't go looking for a System.IO.FileWriter class.
            </remarks>
        </member>
        <member name="F:System.IO.IOHelper.DefaultOverwriteValue">
            <summary>
            Overwrite by default throughout the R5T system.
            </summary>
        </member>
        <member name="T:System.IO.StreamReaderHelper">
            <summary>
            A helper for the <see cref="T:System.IO.StreamReader"/> class.
            </summary>
        </member>
        <member name="M:System.IO.StreamReaderHelper.NewLeaveOpen(System.IO.Stream)">
            <summary>
            The <see cref="T:System.IO.StreamReader"/> class has a constructor that helpfully leaves the underlying stream open after reading. However, this constructor puts the argument to leave the underlying stream open at the end of the input arguments list, behind lots of values crazy random values.
            This method produces a <see cref="T:System.IO.StreamReader"/> that will leave the underlying stream open with the ease of the default constructor.
            </summary>
        </member>
        <member name="T:System.IO.StreamWriterHelper">
            <summary>
            A helper for the <see cref="T:System.IO.StreamWriter"/> class.
            </summary>
        </member>
        <member name="M:System.IO.StreamWriterHelper.NewLeaveOpen(System.IO.Stream)">
            <summary>
            The <see cref="T:System.IO.StreamWriter"/> class has a constructor that helpfully leaves the underlying stream open after writing. However, this constructor puts the argument to leave the underlying stream open at the end of the input arguments list, behind lots of values crazy random values.
            This method produces a <see cref="T:System.IO.StreamWriter"/> that will leave the underlying stream open with the ease of the default constructor.
            
            Note: Returned writer produces no BOM.
            </summary>
        </member>
        <member name="M:System.IO.StreamWriterHelper.NewLeaveOpenAddBOM(System.IO.Stream)">
            <summary>
            The <see cref="T:System.IO.StreamWriter"/> class has a constructor that helpfully leaves the underlying stream open after writing. However, this constructor puts the argument to leave the underlying stream open at the end of the input arguments list, behind lots of values crazy random values.
            This method produces a <see cref="T:System.IO.StreamWriter"/> that will leave the underlying stream open with the ease of the default constructor.
            
            Note: Returned writer produces byte-order-marks (BOM).
            </summary>
        </member>
        <member name="M:System.IO.StreamWriterHelper.NewCloseAfter(System.IO.Stream)">
            <summary>
            The <see cref="T:System.IO.StreamWriter"/> class by default closes the underlying stream to which it writes. The <see cref="M:System.IO.StreamWriterHelper.NewLeaveOpen(System.IO.Stream)"/> method creates a <see cref="T:System.IO.StreamWriter"/> that will be left open.
            This method provides the default <see cref="T:System.IO.StreamWriter"/> behavior, to allow library users to get in the habit of using the <see cref="T:System.IO.StreamWriterHelper"/> in all cases, and to make the behavior of the <see cref="T:System.IO.StreamWriter"/> explicit.
            
            Note: Returned writer produces no BOM.
            </summary>
        </member>
        <member name="M:System.IHasOperationResultExtensions.Failed(R5T.Magyar.Results.IHasOperationResult)">
            <summary>
            <inheritdoc cref="M:System.OperationResultExtensions.Failed(R5T.Magyar.Results.OperationResult)"/>
            </summary>
        </member>
        <member name="M:System.IHasOperationResultExtensions.Failed_OrWarning(R5T.Magyar.Results.IHasOperationResult)">
            <summary>
            <inheritdoc cref="M:System.OperationResultExtensions.Failed_OrWarning(R5T.Magyar.Results.OperationResult)"/>
            </summary>
        </member>
        <member name="M:System.IHasOperationResultExtensions.Succeeded_Strict(R5T.Magyar.Results.IHasOperationResult)">
            <summary>
            <inheritdoc cref="M:System.OperationResultExtensions.Succeeded_Strict(R5T.Magyar.Results.OperationResult)"/>
            </summary>
        </member>
        <member name="M:System.IHasOperationResultExtensions.Succeeded_SuccessOrWarning(R5T.Magyar.Results.IHasOperationResult)">
            <summary>
            <inheritdoc cref="M:System.OperationResultExtensions.Succeeded_SuccessOrWarning(R5T.Magyar.Results.OperationResult)"/>
            </summary>
        </member>
        <member name="M:System.IHasOperationResultExtensions.Succeeded(R5T.Magyar.Results.IHasOperationResult)">
            <summary>
            Chooses <see cref="M:System.IHasOperationResultExtensions.Succeeded_SuccessOrWarning(R5T.Magyar.Results.IHasOperationResult)"/> as the default.
            </summary>
        </member>
        <member name="M:System.OperationResultExtensions.Failed(R5T.Magyar.Results.OperationResult)">
            <summary>
            Returns true if the result is <see cref="F:R5T.Magyar.Results.OperationResult.Failure"/>.
            </summary>
        </member>
        <member name="M:System.OperationResultExtensions.Failed_OrWarning(R5T.Magyar.Results.OperationResult)">
            <summary>
            Returns true if the result is <see cref="F:R5T.Magyar.Results.OperationResult.Failure"/> or <see cref="F:R5T.Magyar.Results.OperationResult.Warning"/>.
            </summary>
        </member>
        <member name="M:System.OperationResultExtensions.Succeeded_Strict(R5T.Magyar.Results.OperationResult)">
            <summary>
            Returns true *only* if the result is <see cref="F:R5T.Magyar.Results.OperationResult.Success"/>.
            </summary>
        </member>
        <member name="M:System.OperationResultExtensions.Succeeded_SuccessOrWarning(R5T.Magyar.Results.OperationResult)">
            <summary>
            Returns true if the result is <see cref="F:R5T.Magyar.Results.OperationResult.Success"/> or <see cref="F:R5T.Magyar.Results.OperationResult.Warning"/>.
            </summary>
        </member>
        <member name="M:System.OperationResultExtensions.Succeeded(R5T.Magyar.Results.OperationResult)">
            <summary>
            Chooses <see cref="M:System.OperationResultExtensions.Succeeded_SuccessOrWarning(R5T.Magyar.Results.OperationResult)"/> as the default.
            </summary>
        </member>
        <member name="M:System.OperationResultExtensions.ToStringRepresentation(R5T.Magyar.Results.OperationResult)">
            <summary>
            Chooses <see cref="M:System.OperationResultExtensions.ToStringRepresentationStandard(R5T.Magyar.Results.OperationResult)"/> as the default.
            </summary>
        </member>
        <member name="M:System.Xml.Linq.XDocumentHelper.LoadXDocument(System.String)">
            <summary>
            Loads an XML document.
            </summary>
        </member>
    </members>
</doc>
